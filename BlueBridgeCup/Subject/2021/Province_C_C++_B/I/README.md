## Ideas
题目中给出了两种操作：
1. 当 p~i~ = 0 时，表示将 a~1~, a~2~, · · · , a~qi~ 降序排列；
2. 当 p~i~ = 1 时，表示将 a~qi~ , a~qi+1~, · · · , a~n~ 升序排列。

按照题目暴力排序应该可以骗一点分，但如果想AC，就需要优化算法。可以根据测试用例的范围：1 ≤ n, m ≤ 100000，估计一下时间复杂度要控制在O(nlog n)。

首先对于连续的p=0，即：p~i~=0 q~i~=a；p~i+1~=0 q~i+1~=b。如果b>a，那么(p~i~, q~i~)的操作将无效，因为(p~i+1~, q~i+1~)已经将(p~i~, q~i~)的范围包含了。同理，如果p~i+2~=0; q~i+2~=c，而b>c，那么p~i+2~和q~i+2~的操作也将无效。

然后对于连续的p=1，即：p~i~=1 q~i~=a；p~i+1~=1 q~i+1~=b。同理，如果a<b，那么(p~i+1~, q~i+1~)的操作将无效，因为(p~i~, q~i~)已经将(p~i+1~, q~i+1~)的范围包含了。

因此我们可以总结出，对于连续的p=0和p=1，只需要分别保留q最大和q最小的那次操作即可。

有了上面的简化之后，整个操作序列其实就被压缩成了p=0和p=1的交替操作，由于一开始的序列是升序排列的，所以第一个有效操作肯定是p~i~ = 0，让我们将某一个前缀降序排列。

我们举个例子来分析一下，令n=9，即[1, 2, 3, 4, 5, 6, 7, 8, 9]：
1. p=0，q=3，即1~3位置降序排，变成了[3, 2, 1, 4, 5, 6, 7, 8, 9]
2. p=1，q=7，即7~9位置升序排，不发生变化，还是[3, 2, 1, 4, 5, 6, 7, 8, 9]
3. p=0，q=6，即1~6位置降序排，变成了[6, 5, 4, 3, 2, 1, 7, 8, 9]
4. p=1，q=4，即4~9位置升序排，变成了[6, 5, 4, 1, 2, 3, 7, 8, 9]
5. p=0，q=5，即1~5位置降序排，变成了[6, 5, 4, 2, 1, 3, 7, 8, 9]

通过这个例子我们可以发现一些规律，有些数字的位置被固定下来了，基本不会变。

为了会这样呢？我们分析一下。

对于第1次有效操作，假设是将[1, x]降序排列，由于最初我们的数据都是升序的，所以∀b∈[x+1, n] > ∀a∈[0, x]。

那么之后我们对[y, n]升序排列(y<=x) 的话其实[x, n]这部分是不变的。

这是因为[y, x] ∈ [0, x] < [x+1, n]，所以[x+1, n]这部分的任意值是始终大于[y, x]中的任意值。

因此我们对[y, n]升序排序的话，其实[x, n]这部分不会挪动位置，换句话说，[x, n]已经被固定下来了。

同理，[1, y]其实也被固定下来了，所以说我们不停的操作其实就是不停的从数组的两边向中间固定元素。

我们可以用两个变量 left 和 right，分别表示数组的两边被固定下来的位置，left 不断增加，right 不断减小，最终数组被固定。



## Code
### Python
暴力骗分版本。

```python
if __name__ == '__main__':
    n, m = map(int, input().split())
    nums = [i + 1 for i in range(n)]
    for _ in range(m):
        p, q = map(int, input().split())
        if p == 0:
            nums[:q] = sorted(nums[:q], reverse=True)
        else:
            nums[q - 1:] = sorted(nums[q - 1:])
    print(nums)
```
