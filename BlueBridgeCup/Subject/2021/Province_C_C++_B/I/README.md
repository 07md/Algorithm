## Ideas
题目中给出了两种操作：
1. 当 p~i~ = 0 时，表示将 a~1~, a~2~, · · · , a~qi~ 降序排列；
2. 当 p~i~ = 1 时，表示将 a~qi~ , a~qi+1~, · · · , a~n~ 升序排列。

按照题目暴力排序应该可以骗一点分，但如果想AC，就需要优化算法。

首先对于连续的p=0，即：p~i~=0 q~i~=a；p~i+1~=0 q~i+1~=b。如果b>a，那么(p~i~, q~i~)的操作将无效，因为(p~i+1~, q~i+1~)已经将(p~i~, q~i~)的范围包含了。同理，如果p~i+2~=0; q~i+2~=c，而b>c，那么p~i+2~和q~i+2~的操作也将无效。

然后对于连续的p=1，即：p~i~=1 q~i~=a；p~i+1~=1 q~i+1~=b。同理，如果a<b，那么(p~i+1~, q~i+1~)的操作将无效，因为(p~i~, q~i~)已经将(p~i+1~, q~i+1~)的范围包含了。

因此我们可以总结出，对于连续的p=0和p=1，只需要分别保留q最大和q最小的那次操作即可。

有了上面的简化之后，整个操作序列其实就被压缩成了p=0和p=1的交替操作，由于一开始的序列是升序排列的，所以第一个有效操作肯定是p~i~ = 0，让我们将某一个前缀降序排列。

我们举个例子来分析一下，令n=5：
1. 第1次有效操作：p=0，q=2，将红色元素降序排列；
2. 第2次有效操作：p=1，q=4，将蓝色元素升序排列，实际并没有变化，本来就是升序；
3. 第3次有效操作：p=0，q=4，将红色元素降序排列，我们可以发现这次操作把第1次有效操作的的范围覆盖了，那么其实我们可以只保留这一次的操作，第1和2次有效操作就可以被省略了；

### 时间复杂度
对于所有的测评用例，1 ≤ n, m ≤ 100000，说明时间复杂度要控制在O(nlog n)。

## Code
### Python
暴力骗分版本。

```python
if __name__ == '__main__':
    n, m = map(int, input().split())
    nums = [i + 1 for i in range(n)]
    for _ in range(m):
        p, q = map(int, input().split())
        if p == 0:
            nums[:q] = sorted(nums[:q], reverse=True)
        else:
            nums[q - 1:] = sorted(nums[q - 1:])
    print(nums)
```
